using System.Collections;
using UnityEngine;

/// <summary>
/// LumoBoy — Главный контроллер персонажа.
/// Поддерживает: бег, прыжок, двойной прыжок, парение (вертолётик-хвост),
/// атаку, бег по стенам, скольжение, мобильный ввод.
/// </summary>
[RequireComponent(typeof(Rigidbody2D))]
[RequireComponent(typeof(Animator))]
public class PlayerController : MonoBehaviour
{
[Header(”=== Движение ===”)]
[SerializeField] float moveSpeed = 8f;
[SerializeField] float acceleration = 15f;
[SerializeField] float deceleration = 20f;

```
[Header("=== Прыжок ===")]
[SerializeField] float jumpForce = 16f;
[SerializeField] float fallMultiplier = 3f;       // ускорение падения
[SerializeField] float lowJumpMultiplier = 5f;    // срезание прыжка при отпускании
[SerializeField] float coyoteTime = 0.12f;        // время после края платформы
[SerializeField] float jumpBufferTime = 0.1f;     // буфер нажатия прыжка

[Header("=== Двойной прыжок / Парение ===")]
[SerializeField] int maxExtraJumps = 1;           // 1 = двойной прыжок
[SerializeField] float hoverGravityScale = 0.3f;  // при парении
[SerializeField] float hoverMaxFallSpeed = -2f;   // макс скорость падения при парении
[SerializeField] float hoverDuration = 2.5f;      // сколько можно парить

[Header("=== Бег по стенам ===")]
[SerializeField] float wallSlideSpeed = -2f;
[SerializeField] float wallJumpForceX = 10f;
[SerializeField] float wallJumpForceY = 14f;
[SerializeField] float wallJumpLockTime = 0.15f;  // блокировка управления после прыжка от стены

[Header("=== Атака ===")]
[SerializeField] float attackCooldown = 0.35f;
[SerializeField] Transform attackPoint;
[SerializeField] float attackRadius = 0.7f;
[SerializeField] LayerMask enemyLayers;
[SerializeField] int attackDamage = 1;
[SerializeField] float comboWindowTime = 0.6f;    // окно для комбо

[Header("=== Детекция земли/стены ===")]
[SerializeField] Transform groundCheck;
[SerializeField] float groundCheckRadius = 0.15f;
[SerializeField] LayerMask groundLayer;
[SerializeField] Transform wallCheckLeft;
[SerializeField] Transform wallCheckRight;
[SerializeField] float wallCheckDistance = 0.15f;

// ─── Компоненты ──────────────────────────────────────────────
Rigidbody2D rb;
Animator anim;
SpriteRenderer sr;

// ─── Состояние ───────────────────────────────────────────────
float horizontalInput;
bool jumpPressed;
bool jumpHeld;
bool attackPressed;
bool hoverHeld;

bool isGrounded;
bool isTouchingWallLeft;
bool isTouchingWallRight;
bool isWallSliding;

int extraJumpsLeft;
float coyoteTimeCounter;
float jumpBufferCounter;
float wallJumpLockCounter;

bool isHovering;
float hoverTimer;

bool isAttacking;
float attackTimer;
int comboCount;
float comboTimer;

bool facingRight = true;

// ─── Мобильный ввод (вызывается из MobileInputUI) ────────────
public void SetHorizontalInput(float value) => horizontalInput = value;
public void SetJumpPressed(bool pressed)    { if (pressed) jumpBufferCounter = jumpBufferTime; jumpPressed = pressed; }
public void SetJumpHeld(bool held)          => jumpHeld = held;
public void SetAttackPressed(bool pressed)  => attackPressed = pressed;
public void SetHoverHeld(bool held)         => hoverHeld = held;

void Awake()
{
    rb   = GetComponent<Rigidbody2D>();
    anim = GetComponent<Animator>();
    sr   = GetComponent<SpriteRenderer>();
}

void Update()
{
    // ── Клавиатурный ввод для тестирования в редакторе ──
    #if UNITY_EDITOR
    horizontalInput = Input.GetAxisRaw("Horizontal");
    if (Input.GetButtonDown("Jump"))  jumpBufferCounter = jumpBufferTime;
    jumpHeld    = Input.GetButton("Jump");
    hoverHeld   = Input.GetKey(KeyCode.LeftShift);
    attackPressed = Input.GetButtonDown("Fire1");
    #endif

    CheckGround();
    CheckWalls();
    HandleCoyoteTime();
    HandleJumpBuffer();
    HandleJump();
    HandleAttack();
    HandleHover();
    UpdateAnimator();
    FlipSprite();
}

void FixedUpdate()
{
    HandleMovement();
    HandleGravity();
    HandleWallSlide();
}

// ════════════════════════════════════════════════════════════
//  ДВИЖЕНИЕ
// ════════════════════════════════════════════════════════════
void HandleMovement()
{
    if (wallJumpLockCounter > 0)
    {
        wallJumpLockCounter -= Time.fixedDeltaTime;
        return; // не даём управлять сразу после прыжка от стены
    }

    float targetSpeed = horizontalInput * moveSpeed;
    float speedDiff   = targetSpeed - rb.linearVelocity.x;
    float accelRate   = (Mathf.Abs(targetSpeed) > 0.01f) ? acceleration : deceleration;
    float force       = speedDiff * accelRate;
    rb.AddForce(Vector2.right * force, ForceMode2D.Force);
}

// ════════════════════════════════════════════════════════════
//  ПРЫЖОК
// ════════════════════════════════════════════════════════════
void HandleJump()
{
    if (jumpBufferCounter > 0)
    {
        // Прыжок с земли / coyote time
        if (coyoteTimeCounter > 0)
        {
            Jump(jumpForce);
            jumpBufferCounter = 0;
            return;
        }

        // Прыжок от стены
        if (isTouchingWallLeft || isTouchingWallRight)
        {
            WallJump();
            jumpBufferCounter = 0;
            return;
        }

        // Двойной прыжок
        if (extraJumpsLeft > 0)
        {
            Jump(jumpForce * 0.9f);
            extraJumpsLeft--;
            jumpBufferCounter = 0;
        }
    }

    jumpBufferCounter -= Time.deltaTime;
}

void Jump(float force)
{
    rb.linearVelocity = new Vector2(rb.linearVelocity.x, force);
    isHovering  = false;
    hoverTimer  = 0;
    anim.SetTrigger("Jump");
}

void WallJump()
{
    float dir = isTouchingWallLeft ? 1f : -1f;
    rb.linearVelocity = new Vector2(wallJumpForceX * dir, wallJumpForceY);
    wallJumpLockCounter = wallJumpLockTime;
    isHovering = false;
    anim.SetTrigger("WallJump");
}

// ════════════════════════════════════════════════════════════
//  ГРАВИТАЦИЯ (улучшенная)
// ════════════════════════════════════════════════════════════
void HandleGravity()
{
    if (isHovering) return; // гравитация управляется в HandleHover

    if (rb.linearVelocity.y < 0)
    {
        // Падаем быстрее
        rb.gravityScale = fallMultiplier;
    }
    else if (rb.linearVelocity.y > 0 && !jumpHeld)
    {
        // Срезаем прыжок при отпускании
        rb.gravityScale = lowJumpMultiplier;
    }
    else
    {
        rb.gravityScale = 1f;
    }
}

// ════════════════════════════════════════════════════════════
//  ПАРЕНИЕ (хвост-вертолётик)
// ════════════════════════════════════════════════════════════
void HandleHover()
{
    // Начать парение: только в воздухе, кнопку удерживаем, падаем вниз
    if (hoverHeld && !isGrounded && rb.linearVelocity.y < 0 && !isWallSliding && hoverTimer < hoverDuration)
    {
        isHovering = true;
    }
    else if (!hoverHeld || isGrounded || hoverTimer >= hoverDuration)
    {
        isHovering = false;
    }

    if (isHovering)
    {
        hoverTimer += Time.deltaTime;
        rb.gravityScale = hoverGravityScale;
        // Ограничиваем максимальную скорость падения
        if (rb.linearVelocity.y < hoverMaxFallSpeed)
            rb.linearVelocity = new Vector2(rb.linearVelocity.x, hoverMaxFallSpeed);
    }
    else
    {
        if (isGrounded) hoverTimer = 0; // сброс на земле
    }
}

// ════════════════════════════════════════════════════════════
//  СКОЛЬЖЕНИЕ ПО СТЕНЕ
// ════════════════════════════════════════════════════════════
void HandleWallSlide()
{
    isWallSliding = false;

    if (!isGrounded && (isTouchingWallLeft || isTouchingWallRight) && rb.linearVelocity.y < 0)
    {
        bool slidingLeft  = isTouchingWallLeft  && horizontalInput < 0;
        bool slidingRight = isTouchingWallRight && horizontalInput > 0;

        if (slidingLeft || slidingRight)
        {
            isWallSliding = true;
            rb.gravityScale = 0.5f;
            float clampedY = Mathf.Max(rb.linearVelocity.y, wallSlideSpeed);
            rb.linearVelocity = new Vector2(rb.linearVelocity.x, clampedY);
        }
    }
}

// ════════════════════════════════════════════════════════════
//  АТАКА + КОМБО
// ════════════════════════════════════════════════════════════
void HandleAttack()
{
    attackTimer -= Time.deltaTime;
    comboTimer  -= Time.deltaTime;

    if (comboTimer <= 0) comboCount = 0;

    if (attackPressed && attackTimer <= 0)
    {
        attackPressed = false;
        attackTimer   = attackCooldown;
        comboTimer    = comboWindowTime;
        comboCount    = Mathf.Min(comboCount + 1, 3);

        string animName = $"Attack{comboCount}"; // Attack1, Attack2, Attack3
        anim.SetTrigger(animName);

        PerformAttackHit();
    }
}

void PerformAttackHit()
{
    if (attackPoint == null) return;

    Collider2D[] hits = Physics2D.OverlapCircleAll(attackPoint.position, attackRadius, enemyLayers);
    foreach (var hit in hits)
    {
        // Отталкиваем врага
        Rigidbody2D enemyRb = hit.GetComponent<Rigidbody2D>();
        if (enemyRb != null)
        {
            Vector2 dir = (hit.transform.position - transform.position).normalized;
            enemyRb.AddForce(dir * 5f, ForceMode2D.Impulse);
        }

        // Наносим урон
        IDamageable damageable = hit.GetComponent<IDamageable>();
        damageable?.TakeDamage(attackDamage);
    }
}

// ════════════════════════════════════════════════════════════
//  ДЕТЕКЦИЯ ЗЕМЛИ / СТЕНЫ
// ════════════════════════════════════════════════════════════
void CheckGround()
{
    bool wasGrounded = isGrounded;
    isGrounded = Physics2D.OverlapCircle(groundCheck.position, groundCheckRadius, groundLayer);

    if (isGrounded && !wasGrounded)
    {
        // Приземление
        extraJumpsLeft = maxExtraJumps;
        hoverTimer     = 0;
        anim.SetTrigger("Land");
    }
}

void CheckWalls()
{
    isTouchingWallLeft  = wallCheckLeft  != null &&
        Physics2D.Raycast(wallCheckLeft.position,  Vector2.left,  wallCheckDistance, groundLayer);
    isTouchingWallRight = wallCheckRight != null &&
        Physics2D.Raycast(wallCheckRight.position, Vector2.right, wallCheckDistance, groundLayer);
}

void HandleCoyoteTime()
{
    if (isGrounded)
        coyoteTimeCounter = coyoteTime;
    else
        coyoteTimeCounter -= Time.deltaTime;
}

void HandleJumpBuffer()
{
    jumpBufferCounter -= Time.deltaTime;
}

// ════════════════════════════════════════════════════════════
//  АНИМАЦИИ
// ════════════════════════════════════════════════════════════
void UpdateAnimator()
{
    anim.SetFloat("Speed",    Mathf.Abs(rb.linearVelocity.x));
    anim.SetFloat("VelocityY", rb.linearVelocity.y);
    anim.SetBool("IsGrounded",    isGrounded);
    anim.SetBool("IsWallSliding", isWallSliding);
    anim.SetBool("IsHovering",    isHovering);
}

void FlipSprite()
{
    if (horizontalInput > 0.01f && !facingRight)  Flip();
    if (horizontalInput < -0.01f && facingRight) Flip();
}

void Flip()
{
    facingRight = !facingRight;
    sr.flipX    = !facingRight;

    // Переворачиваем точку атаки
    if (attackPoint != null)
    {
        Vector3 ap = attackPoint.localPosition;
        attackPoint.localPosition = new Vector3(-ap.x, ap.y, ap.z);
    }
}

// ════════════════════════════════════════════════════════════
//  ОТЛАДКА
// ════════════════════════════════════════════════════════════
void OnDrawGizmosSelected()
{
    if (groundCheck != null)
    {
        Gizmos.color = isGrounded ? Color.green : Color.red;
        Gizmos.DrawWireSphere(groundCheck.position, groundCheckRadius);
    }
    if (attackPoint != null)
    {
        Gizmos.color = Color.yellow;
        Gizmos.DrawWireSphere(attackPoint.position, attackRadius);
    }
}
```

}

/// <summary>Интерфейс для всего, что можно ударить.</summary>
public interface IDamageable
{
void TakeDamage(int damage);
}
